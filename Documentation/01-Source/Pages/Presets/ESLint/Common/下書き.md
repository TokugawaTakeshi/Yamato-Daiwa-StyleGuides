# `@stylistic/no-confusing-arrow`

```json
{
  "no-confusing-arrow": [ "error", { "allowParens": true } ]
}
```

Тут важно добавить опцию `allowParens: true` - это одно из действий, которое нужно выполнить для устранения конфликта 
  этого правила с `no-extra-parens` в выражениях типа 
`preValidationModifications: (rawValue: unknown): unknown => (isNumber(rawValue) ? rawValue.toString() : rawValue), }` 
(последнему нужно также добавить `enforceForArrowConditionals: false`).

# `@stylistic/no-extra-parens`

```json
{
  "@stylistic/no-extra-parens": [
    "warn",
    "all",
    {
      "nestedBinaryExpressions": false,
      "enforceForArrowConditionals": false
    }
  ]
}
```

Задачей этого правила является предотвращение случаев, когда программист думает, что скобки нужны, а на самом деле 
  не нужны, то есть не влияют на порядок действий. 
Тем не менее скобки применяются не только для изменения порядка действий, но и для улучшения читабельности кода. 
По нашему опыту, есть нужда в исключениях `nestedBinaryExpressions` (когда идёт сложная комбинация "и" и "или", добавить 
  пример) и `enforceForArrowConditionals` - для устранения конфликта с `no-confusing-arrow`.


# `@stylistic/no-extra-semi`

```json
{
  "@stylistic/no-extra-semi": "error"
}
```


Данное правило нацелено не на использование точки с запятой как таковой, а на использование её тогда, когда она
  обычно не требуется (например, две подряд идущие точки с запятой или точка с запятой после метода).


# `@stylistic/lines-around-comment`

```json
{
  "@stylistic/lines-around-comment": [
    "warn",
    { "beforeBlockComment": true }
  ]  
}

```

 
Если перед комментарием не ставить пробел, будет мешанина.


# `@stylistic/lines-between-class-members`

```json
{
  "@stylistic/lines-between-class-members": [
    "warn",
    {
      "enforce": [
        {
          "blankLine": "always",
          "prev": "field",
          "next": "method"
        },
        {
          "blankLine": "always",
          "prev": "method",
          "next": "method"
        },
        {
          "blankLine": "always",
          "prev": "method",
          "next": "field"
        }
      ]
    }
  ]
}
```

Если писать членов класса слитно, получится мешанина.
Мы можем опускать пустые строки разве что между полями класса, когда они однородные. 


# `@stylistic/max-len`

```json
{
  "@stylistic/max-len": [
    "warn",
    {
      "code": 130,
      "ignoreUrls": true,
      "ignorePattern": "^\\s{4}\"[@~]?[\\w/:.-]+\";\\s*$"
    }
  ]
}
```

Мы считаем, что 80 колонок - маловато, даже при отступе в 2 проблема.
Мы обычно берём 120 колонок за норму и стараемся её не нарушать, но максимально допустимую длину устанавливаем в 130. 

Тут важно добавить исключение для деклараций импортов так как разорвать пути нельзя. 
Также, если не установить исключение для ссылок в комментариях, то по этим ссылкам просто нельзя будет перейти.

# `@stylistic/max-statements-per-line`

```json
{
  "@stylistic/max-statements-per-line": [ "warn", { "max": 2 } ]
}
```

Двух вполне достаточно, например когда создаём простую функцию типа `function foo() { bar = 1; }`.


# `@stylistic/member-delimiter-style`

```json
{
  "@typescript-eslint/member-delimiter-style": [
    "warn",
    {
      "multiline": {
        "delimiter": "semi",
        "requireLast": true
      },
      "singleline": {
        "delimiter": "semi",
        "requireLast": true
      }
    }{}
  ]
}
```

Велик соблазн вообще отказаться от разграничителей, но это не будет вписываться в общую стилистику кода, где хотя и 
  по высосанным из пальца, на причинам разграничители используются. 
Точка с запятой выбрана потому, чтобы объявление типа контрастировало с инициализацией переменных (например, когда 
  параметр типа "объект" сразу же разбирается.)


# `@stylistic/no-mixed-spaces-and-tabs`

```json
{
  "@stylistic/no-mixed-spaces-and-tabs": "warn"
}
```

В принципе нарушение этого правила не критично (для ECMAScript, но не для indent-based языков), 
  но нам как-то лучше когда всё под контролем.


# `@stylistic/no-multi-spaces`

```json
{
  "@stylistic/no-multi-spaces": "warn"
}
```

Одного пробела вполне достаточно для нормальной читабельности.


# `@stylistic/no-multiple-empty-lines`

```json
{
  "@stylistic/no-multiple-empty-lines": [
    "warn",
    {
      "max": 2,
      "maxBOF": 0,
      "maxEOF": 1
    }
  ]
}
```

Мы не согласны с тем, что в документации сказано про "while others feel that it helps improve readability", напротив,
  когда весь код сжат в одну кучу, его намного тяжелее читать.
Это подобно тому, как кто-нибудь при выступлении долго и монотонно говорит без пауз - согласитесь, слушать такое тяжело.
Качественный код необходимо разбивать на логические блоки, и пустые строки - один из способов это сделать.

Что касается "excess whitespace takes up more of the screen", то файл с кодом - это не страница книги, и здесь
  пространство не так важно, как читаемость.
Ну и конечно, беспокоиться о том, что код с пустыми строками займёт больше памяти не стоит, так как современные инструменты
  разработки могут минифицировать код.

Мы разрешаем максимум 2 пустых строки - случаев, для которых по какой-то более-менее высосанной из пальца причине нужно 
  больше, не возникало. 
В начале файла ставить пустые строки причины нет. 
Пустая строка в конце файла требуется другим правилом - кажется eof.


# `@stylistic/object-curly-newline`

```json
{
  "@stylistic/object-curly-newline": [ "warn", { "consistent": true } ]
}
```

Всегда бывает по-разному.  
Иногда и три коротких свойства можно в одной строке уписать, иногда и одно свойство довольно длинное, 
  потому его нужны вынести в отдельную строку. 
Тут главное быть последовательным, потому `{ "consistent": true }`.


### Унификация эквивалентных записей

# `@stylistic/array-bracket-newline`


```json
{
  "@stylistic/array-bracket-newline": [ "warn", "consistent" ]
}
```

Когда один-два элемента с малым количеством символов, то не вижу смысла записывать массив в три строки: при наличии
  пробелов между элементами и скобками (правила `array-bracket-spacing` и `array-element-newline` соответственно)
  у кода достаточная читабельность:

```typescript
const sampleArray1: Array<number> = [ 1 ];
const sampleArray2: Array<number> = [ 1, 2 ];
```

Когда же элементов много, то запись в одну строку может привести к нарушению правила `@stylistic/max-len`, поэтому в 
  таких случаях следует записывать в несколько строк.


# `@stylistic/array-bracket-spacing`

```json
{
  "@stylistic/array-bracket-newline": [ "warn", "consistent" ]
}
```

Считаю, что в исходном коде читабельность гораздо важнее компактности.
Наличие подобных пробелов сходно чёткой речи с правильно расставленными паузами - такую речь довольно приятно слушать.


# `@stylistic/array-element-newline`

```json
{
  "@stylistic/array-element-newline": [ "warn", "consistent" ]  
}
```

Я не согласен с предпочтениями разработчиков ESLint насчёт того, что даже если в длинных массивах первый элемент 
  записан на одной строке со скобкой, то следующий нужно писать на новой строке:

```javascript
const c = [1,
    2];

const d = [1,
    2,
    3];

const d = [
  1,
  2,
  3
];
```

Допускаю обе формы записи - в одну строку для коротких массивов и в несколько для длинных.


# `@stylistic/arrow-parens`

```json
{
  "@stylistic/arrow-parens": [ "warn", "always" ]  
}
```

У нас основным языком является TypeScript, а в TypeScript аннотировать тип параметра без скобок невозможно, 
  даже если параметр один. 
Поэтому скобки обязательны.


# `@stylistic/arrow-spacing`

```json
{
  "@stylistic/arrow-spacing": [ "warn", { "before": true, "after": true } ]
}
```

В целом, мы расставляем пробелы для удобочитаемости, и тут тоже так.


# `@stylistic/block-spacing`

```json
{
  "@stylistic/block-spacing": [ "warn", "always" ] 
}
```

В целом, мы расставляем пробелы для удобочитаемости, и тут тоже так.


# `@stylistic/brace-style`

```json
{
  "@stylistic/brace-style": [ "warn", "1tbs", { "allowSingleLine": true } ]
}
```

Для ECMAScript типичен стиль 1tbs, и мы его тоже придерживаемся. 
Лишь изредка возникает соблазн написать в стиле Олмана (пример).


# `@stylistic/comma-dangle`

```json
{
  "@stylistic/comma-dangle": [ "warn", "never" ]
}
```

Мы не ставим запятые, потому что они создают ощущение недописанного кода. 
Действительно, в СКВ смотрится чище при добавлении строк, но это незначительно.


# `@stylistic/comma-spacing`

```json
{
  "@stylistic/comma-spacing": [ "warn", { "before": false, "after": true } ]
}
```

В соответствии с правилами обычной грамматики, к которой должен быть максимально близок легко читаемый код, 
  пробел нужно ставить после запятой, а не перед.


# `@stylistic/comma-style`

```json
{
  "@stylistic/comma-style": [　"error",　"last"　]
}
```

Мы придерживаемся стандартной записи, при которой сначала ставится запятая, а потом идёт перенос строки потому что 
  особых причин для другого стиля нет. 
"One of the justifications for using Comma First style is that it can help track missing and trailing commas." - 
  для TypeScript вкупе с запретом на trailing commas это не имеет значения.


# `@stylistic/computed-property-spacing`

```json
{
  "@stylistic/computed-property-spacing": [　"warn",　"never"　]
}
```

Мы в данном случае пробел не ставим, чтобы был контраст с массивами, где пробелы уже обязательны в наших правилах.


# `stylistic/dot-location`

```json
{
  "@stylistic/dot-location": [ "warn", "object" ]  
}
```

Здесь мы придерживаемся нестандартного стиля - object. 
Такой стиль написания был унифицирован с правилом написания знаков арифметических действий, где согласно принципу 
  предсказуемости кода знак остаётся на строке перед переносом. 
В данном случае мы также понимаем, что если n-ая строка заканчивается на точку, значит в n+1-ой строке будет что-то вызвано.


# `@stylistic/function-call-argument-newline`

```json
{
  "@stylistic/function-call-argument-newline": [ "warn", "consistent" ]
}
```

Мы позволяем оба способа, потому что когда аргументы короткие, запись их в одну строчку вполне себе читаема 
  (запятая и пробел чётко разделяют их), но иногда имена аргументов могут быть длинными и тогда их в одну строку 
  просто не уместить. 
Главное - не писать вразнобой и соответствующая опция, к счастью, имеется.


# `@stylistic/function-call-spacing`

```json
{
  "@stylistic/function-call-spacing": "warn"
}
```

Споры о том, что легче читать тут могут быть бесконечны. 
В принципе запись типа имя функции() без пробела пере скобками - стандартное для многих языков выражение вызова 
  функции/метода.


# `@stylistic/function-paren-newline`

```json
{
  "@stylistic/function-paren-newline": [ "warn", "consistent" ]
}
```

Мы позволяем оба способа, потому что когда аргументы короткие, запись их в одну строчку вполне себе читаема 
  (запятая и пробел чётко разделяют их), но иногда имена аргументов могут быть длинными и тогда их в одну строку 
  просто не уместить. 
Главное - не писать вразнобой и соответствующая опция, к счастью, имеется.


# `@stylistic/generator-star-spacing`

```json
{
  "@stylistic/generator-star-spacing": [ "warn", { "before": true, "after": false } ] 
}
```

# `@stylistic/key-spacing`

```json
{
  "@stylistic/key-spacing": [
    "warn",
    {
      "beforeColon": false,
      "afterColon": true,
      "mode": "strict"
    }
  ]
}
```

У нас никаких логических возражений против наиболее устоявшейся формы записи, при которой перед двоеточием пробела нет, 
  а после него - есть.


# `@stylistic/keyword-spacing`

```json
{
  "@stylistic/keyword-spacing": [
    "warn",
    {
      "before": true,
      "after": true
    }
  ]
}
```

Мы размежаем ключевые словам пробелами дабы они не сливались с остальными токенами.


# `@stylistic/new-parens`

```json
{
  "@stylistic/new-parens": "error"
}
```

Мы считаем, что вызов функции-конструктора, как и вызов других функций должен иметь скобки, как и во многих других
  C-подобных языках.
Вариант без скобок объявляется невалидным синтаксисом.


# `@stylistic/newline-per-chained-call`

```json
{
  "@stylistic/newline-per-chained-call": [ "warn", { "ignoreChainWithDepth": 2 } ]
}
```

Мы допускаем запись в одну строчку цепи из двух вызовов, но при трёх и более вызовах требуем переноса строки,
   так как это становится тяжелее читать.


# `@stylistic/no-floating-decimal`

```json
{
  "@stylistic/no-floating-decimal": "error"
}
```

Мы всегда (в том числе в и в CSS) требуем указывать 0 перед точкой, потому что это верно математически.
Чтобы сделать синтаксис без скобок невалидным, данное нарушения данного правила имеют статус error.


# `"@stylistic/no-whitespace-before-property`

```json
{
  "@stylistic/no-mixed-spaces-and-tabs": "warn"
}
```
Спорить о том, что легче читать, можно бесконечно, поэтому тут мы придерживаемся популярной формы записи - без пробела.


# "@stylistic/object-curly-spacing" 

```json
{
  "@stylistic/object-curly-spacing": [ "warn", "always" ]
}
```

Мы всегда ставим пробелы. 
Сказать субъективно, что "так выглядит грязнее" или "так сложнее читать" можно, но это будет спорно.


# @stylistic/object-property-newline

```json
{
  "@stylistic/object-property-newline": [
    "warn",
    {
      "allowAllPropertiesOnSameLine": true
    }
  ]
}
```

Достаточно исключения allowAllPropertiesOnSameLine.


# `@stylistic/operator-linebreak`

```json
{
  "@stylistic/operator-linebreak": [ "warn", "after" ]
}
```

Мы переносим строку после знака в рамках доктрины "предсказуемости кода".


# `@stylistic/one-var-declaration-per-line`

```json
{
  "@stylistic/one-var-declaration-per-line": [ "error", "initializations" ]
}
```

Примечательно, но при качественном коде соблазн записи двух и более неинициализированных переменных в одну строчку 
  возникает довольно редко, особенно для TypeScript, где помимо имени требуется указать тип 
  (мы считаем, что если этого не делать, то нельзя себя называть TypeScript-программистом). 
Имена качественных переменных зачастую не такие короткие. 
Всё это приводит к выводу, что во имя унификации можно не позволять две и более переменных на одну строку.


# `@stylistic/quote-props`

```JSON
{ "@stylistic/quote-props": [ "warn", "as-needed" ] }
```

Данное правило можно отнести к группе "унификация... " при условии, что код у нас ES5 и старше. 
К счастью, большинство современных сред поддерживают ES6 и старше, а потому без необходимости скобок можно не ставить - 
тем более и использованием транспортеров.


# `"@stylistic/quotes"`

```JSON
{
  "@stylistic/quotes": [ "error", "double", { "avoidEscape": true } ]
}
```

О том, какие кавычки нужно использовать, пожалуй одни из самых горячих, но в то же время бесполезных споров. 
Говорят, например, что одинарные кавычки - правила хорошего тона, но какого-либо логического обоснования мы не видели. 
Двойные кавычки мы выбираем как единый способ записи строчных литералов для C-подобных языков 
(в некоторых языках, например Java и C# одинарные кавычки не могут быть использованы для строчных литералов, 
а в других - как и ECMAScript доступны вариации.) 
Разумеется, мы позволяем использовать template literal, когда он нужен.


# `"@stylistic/rest-spread-spacing"`

```JSON
{
  "@stylistic/rest-spread-spacing": [ "warn", "never" ]
}
```

Как и другие унарные операторы, мы требуем написания вплотную.


# `"@stylistic/semi"`

```json
{
  "@stylistic/semi": "error" 
}
```

Ещё одна тема для бесполезных холиваров наряду с двойными и одинарными кавычками. 
Скажем так: JavaScript да и многие другие C-подобные языки не разрабатывались как языки с лаконичными ситаксисом 
  (как Питон), а потому обойтись без точек с запятой во 100% невозможно (например, в for). 
Поэтому наличие точек с запятой является особенностью C-подобных языков, а JavaScript на позицию языка, 
  "значительно отдалившегося от своего предка и предвнесший гораздо более лаконичный синтаксис" не претендует.


# `"@stylistic/semi-spacing"`

```JSON
{
  "@stylistic/semi-spacing": [ "warn", { "before": false, "after": true } ]
}
```

Мало кто скажет, что когда что-то идёт без пробела после точек с запятой, то это легче читать, чем когда есть пробел.



# `"@stylistic/semi-style"`

```JSON
{
  "@stylistic/semi-style": [ "warn", "last" ]
}
```

Переносить точку с запятой на следующую строку можно только из непонимания концепции этого оператора. 
Этот оператор как раз является указанием того, что объявление инструкции завершено и на следующей строке будет новая 
  инструкция.


# `"@stylistic/space-before-blocks"`

```JSON
{
  "@stylistic/space-before-blocks": "warn"
}
```

Мы размежаем согласно фундаментальному "пробелы улучшают читабельность".


# `"@stylistic/space-before-function-paren"` 

```JSON
{
  "@stylistic/space-before-function-paren": [ "warn", { "anonymous": "always", "named": "never", "asyncArrow": "always" } ]
}
```

Скобки, идущие сразу после идентификатора указывают, что это вызов функции/метода. 
Это типично для C-подобных языков. 
Пробел после скобок уже даёт хорошую читабельность. 
Но поскольку анонимные функции (в частности, асинхронные) имени не содержат, то для них - исключение.


# `"@stylistic/space-in-parens"`

```JSON
{
  "@stylistic/space-in-parens": [ "warn", "never" ]
}
```

Тут наличие пробелов в принципе мало что даёт. 
Можно сказать, что `const x = ( 1 + 2 ) * 3;` читается легче, `чем const x = (1 + 2) * 3;`, 
но данное распространяется и на `foo( 'bar' );`, а добавить исключение для одного члена нельзя.


### Другие

# `@stylistic/eol-last`

```json
{
  "@stylistic/eol-last": [　"error",　"warn"　]
}
```

Мы приняли это правило, потому что несмотря на его мерзость аргументов, доказывающих безопасность игнорирования этой 
  идиомы у нас не нашлось.
Мерзость заключается в том, что для третьего десятилетия 21-го века с его искусственными интеллектами машинам пора бы 
  уже самостоятельно обрабатывать случай, когда последняя пустая строка отсутствует.

### Не вошли

# `consistent-return`

Данное правило является конфликтным, например конфликтует с `no-useless-return` или `no-undefined`.
TypeScript сам разругается, если возвращаемое значение не соответствует аннотированному, так что от данного правила можно
  отказаться при условии, что аннотация возвращаемого типа обязательна..


# `prefer-template`

Какое-то время мы использовали это правила, однако в какой-то момент оно 
  [стало конфликтовать с "@typescript-eslint/no-useless-template-literals"](https://stackoverflow.com/q/78046218/4818123).
Вновь проанализировав [документацию для "prefer-template"](https://eslint.org/docs/latest/rules/prefer-template) мы
  заметили, что все примере являются однострочными (проверено в марте 2024 года), например `"Hello, " + name + "!";`,
  а в случах нескольких строк [возникают проблемы](https://stackoverflow.com/q/78046218/4818123).
В итоге, принято решение отказаться от этого правила из-за этих проблем.


# `@stylistic/implicit-arrow-linebreak`

Для коротких функций мы допускаем запись в одну строку, а в случае длинных функций разбиваем на несколько строк, причём
  перенос делаем после стрелки по принципу предсказуемости.


# `@stylistic/linebreak-style`

Сделать это правило по умолчанию (в зависимости от ОС) вполне безопасно, потому что системы контроля версий, 
  без которых не обходится ни один современный серьёзный проект, могут автоматически заменять 
  escape-последовательности на нужные.


# `@stylistic/multiline-ternary`

Всё зависит от длины операндов. 
Опция always-multiline не покрывает те случаи, когда один операнд короткий, а другой - длинный. 


# `@stylistic/no-tabs`

На данный момент не видим особой причины запрещать табы.


# `@stylistic/no-trailing-spaces`

На соблюдение этого правила может потребоваться много времени. 
Хотя мы этого не замечаем, мы чуть ли не в каждом строке оставляем один или более пробелов. 
В процессе написания кода, ESLint будет буквально спамить за нарушение этого правила. 
Поскольку нарушение этого правила никаких отрицательных эффектов типа снижения производительности 
(если брать веб-приложения, то там минификация продакшен-кода - стандартная процедура), то соблюдать его особого смысла нет.


# `nonblock-statement-body-position`

Наличие правила `curly` делает это правило ненужным.



# `@stylistic/padded-blocks`

В целом, правило небесполезное, но к сожалению, у него недостаточно опций, чтобы настроить его под наши гайдлайны. 
А подход наш таков: если блок состоит из одной -двух строк, то тогда добавление в него отступов особо читабельность 
  не увеличит, а вот если там какие-то более сложные алгоритмы, где последовательности можно разбивать на группы, 
  то тогда добавление отступов уже требуется.


# `@stylistic/padding-line-between-statements`

Мы осуществляем группировку в последовательности строк без пробелов в первую очередь семантически.
Поэтому вгонять себя в жесткие рамки типа "отступов никогда не должно быть" или "они должны быть всегда" мы не будет.
Опций, конечно, много, но семантику они понять немогут.


## TypeScript
### Безопасность типизации
# `use-unknown-in-catch-callback-variables`

```json
{
  "use-unknown-in-catch-callback-variables": "error"
}
```

Использование `any`, в том числе в обработчиках ошибок - это смертный грех, за который инженер не имеет право
  упомянуть TypeScript среди используемых технологий в резюме.

### Предотвращение алгоритмических ошибок

# `@typescript-eslint/no-array-delete`

```json
{
  "@typescript-eslint/no-array-delete": "error"
}
```
