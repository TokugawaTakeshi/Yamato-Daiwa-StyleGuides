extends ../../../../../node_modules/@yamato-daiwa/programming_documentation/Layouts/TwoColumns/TwoColumnsLayout.pug


block append Requirements

  include ../../../../SharedAssets/Markup/SharedAssets.english.pug
  include ../../../../SharedComponents/SharedComponents.english.pug


block append Metadata

  -

    RegularWebPageTemplate__YDF.configure({
      metadata: {
        title: buildHTML_PageTitle("ESLint"),
        description: ""
      },
      stylesSheetsURIs: [
        "$CommonStyles",
        "$LayoutsStyles/TwoColumns/TwoColumnsLayout.css",
        "$PreMadesStyles",
        "@CustomizedExternalComponents"
      ]
    });

    RoutingEmulator.setCurrentRoute("presets.ESLint.general");

    LanguageDropDownList__YDF_DK.setLinks({
      japanese: routing.japanese.presets.$children.ESLint.$children.general.$URI,
      russian: routing.russian.presets.$children.ESLint.$children.general.$URI
    });

    const {
      $sectioning: localizedSectioning,
      $heading: topHeading
    } = routing.english.presets.$children.ESLint.$children.general;


block append HeadScripts

  if __IS_PRODUCTION_BUILDING_MODE__

    +GoogleAnalyticsScript


block append SpecificContent

  article

    //- ━━━ General Rules for Both TypeScript and JavaScript ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    h1.Article-Heading1= topHeading

    //- ━━━ ECMAScript Code Validity ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    +Heading--YDF({
      level: 2,
      text: localizedSectioning.codeValidity.$heading,
      HTML_ID: localizedSectioning.codeValidity.$anchor
    }).Article-Heading2

    p.Article-Paragraph.
      The #[+ImportantEntity--YDID ECMA-Script] standard is pretty liberal because it is allowing to write the
        meaningless code frequently #[+Keyphrase--YDID without runtime errors].
      For example, in the #[+Term--YDID class] declaration, it is possible to declare #[+Term--YDID getter] which
        return nothing that is contradicting to the #[+Term--YDID getter] concept.
      The target of this group's rules is significantly decrease the volume of such meaningless code.


    //- ─── array-callback-return ──────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.codeValidity.$children["array-callback-return"].$heading,
      HTML_ID: localizedSectioning.codeValidity.$children["array-callback-return"].$anchor
    }).Article-Heading3

    +CodeViewer--YDF({ title: "Rule Configuration" })
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.JSON }).
        { "array-callback-return": "error" }

    +Blockquote--YDF

      p.Article-Paragraph.
        #[+ImportantEntity__Code--YDID Array] has several #[+Term--YDID methods] for filtering, mapping, and folding.
        If we forget to write return statement in a #[+Term--YDID callback] of those, it’s probably a mistake.
        If you don’t want to use a return or don’t need the returned results, consider using
          #[+ImportantEntity__Code--YDID .forEach] instead.

      +InformationSourceReference--YDF.Blockquote--YDF-ReferenceToSource
        +Link--YDF({
          unendorsedExternalURI: "https://eslint.org/docs/latest/rules/array-callback-return"
        }).Article-Link Official ESLint documentation

    p.Article-Paragraph.
      If to use the #[+ImportantEntity--YDID TypeScript] with set up of notification about errors, such weird things will
        be detected immideatly because #[+Keyword--YDID all] #[+Keyword__Contrast--YDID standard] #[+Term--YDID methods]
        (including the #[+Term--YDID arrays'] #[+Term__Contrast--YDID methods]) has #[+Keyword--YDID built-in]
        #[+ImportantEntity--YDID TypeScript] types definitions..
      Thus, #[+Keyphrase--YDID in the case of #[+ImportantEntity--YDID TypeScript] usage], such rule is like the
        fallback.


    //- ─── constructor-super ──────────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.codeValidity.$children["constructor-super"].$heading,
      HTML_ID: localizedSectioning.codeValidity.$children["constructor-super"].$anchor
    }).Article-Heading3

    +CodeViewer--YDF({ title: "Rule Configuration" })
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.JSON }).
        { "constructor-super": "error" }

    +Blockquote--YDF

      p.Article-Paragraph.
        #[+Term--YDID Constructors] of #[+Keyword--YDID derived] #[+Term--YDID classes] #[+Keyword--YDID must] call
          #[+ImportantEntity__Code--YDID super()].
        Constructors of #[+Keyword--YDID non] derived #[+Term--YDID classes] must&nbsp;#[+Keyword--YDID not]&nbsp;call
          #[+ImportantEntity__Code--YDID super()].
        If this is not observed, the #[+ImportantEntity--YDID JavaScript] engine will raise a runtime error.

      +InformationSourceReference--YDF.Blockquote--YDF-ReferenceToSource
        +Link--YDF({
          unendorsedExternalURI: "https://eslint.org/docs/latest/rules/constructor-super"
        }).Article-Link Official ESLint documentation

    p.Article-Paragraph.
      If to access to #[+ImportantEntity__Code--YDID this] (the #[+Term--YDID context variable]) is the
        #[+Keyphrase--YDID inherited] #[+Term--YDID class] before #[+ImportantEntity__Code--YDID super()]
        #[+Term--YDID invocation], the #[+ImportantEntity--YDID TypeScript] type checker will emit the
        #[+ImportantEntity__Code--YDID TS2377] #[+Term--YDID error].
      About pure #[+ImportantEntity--YDID JavaScript], without this #[+Term--YDID ESLint] rule, such error could be
        detected only by best #[+Term--YDID IDEs] such as #[+SecondaryEntity--YDID IntelliJ IDEA].


    //- ─── getter-return ──────────────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.codeValidity.$children["getter-return"].$heading,
      HTML_ID: localizedSectioning.codeValidity.$children["getter-return"].$anchor
    }).Article-Heading3

    +CodeViewer--YDF({ title: "Rule Configuration" })
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.JSON }).
        { "getter-return": "error" }

    +Blockquote--YDF

      p.Article-Paragraph.
        The #[+ImportantEntity__Code--YDID get] #[+Term--YDID syntax] binds an #[+Term--YDID object]
          #[+Term__Contrast--YDID property] to a #[+Term--YDID function] that will be called when that
          #[+Term--YDID property] is looked up.
        It was first introduced in #[+ImportantEntity--YDID ECMAScript 5].
        Note that #[+Keyword--YDID every] #[+Term--YDID getter] is #[+Keyword--YDID expected] to return a value.

      +InformationSourceReference--YDF.Blockquote--YDF-ReferenceToSource
        +Link--YDF({
          unendorsedExternalURI: "https://eslint.org/docs/latest/rules/getter-return"
        }).Article-Link Official ESLint documentation

    p.Article-Paragraph.
      The violation of this rule is contradicting to #[+Term--YDID getter] #[+Keyword--YDID concept].
      According to it, the #[+Term--YDID getter] is the member which returns some value either with preliminary
        computing or without it.
      If the code of #[+Term--YDID getter] #[+Keyphrase--YDID which returns nothing] has been written consciously,
        the programmer does&nbsp;not&nbsp;understand own actions.

    p.Article-Paragraph.
      If ot create the #[+Term--YDID getter] at the #[+Term__Contrast--YDID class] or #[+Term__Contrast--YDID object]
        by #[+ImportantEntity--YDID TypeScript] language, the #[+ImportantEntity--YDID TypeScript] types checker will
        emit the #[+ImportantEntity--YDID TS2378] error where will be clearly said that the #[+Term--YDID getter]
        #[+Keyword--YDID must] return something.
      If the code has been written on plain #[+ImportantEntity--YDID JavaScript], even leading IDEs like
        #[+ImportantEntity--YDID IntelliJ IDEA] will #[+Keyword--YDID not]&nbsp;notify about this issue (checked on
        #[+SecondaryEntity--YDID 2024.1.1] version).


    //- ━━━ Algorithmic Errors Preventing ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    +Heading--YDF({
      level: 2,
      text: localizedSectioning.algorithmicErrorsPreventing.$heading,
      HTML_ID: localizedSectioning.algorithmicErrorsPreventing.$anchor
    }).Article-Heading2

    p.Article-Paragraph.
      Unlike the previous group, the violations of the current group could be represented by completely valid code, but
        with high probability be the algorithmic error.
      The corresponding rules also has been documented well, so for most rules of this group there is nothing to comment
        from our side.

    //- ─── for-direction ──────────────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.algorithmicErrorsPreventing.$children["for-direction"].$heading,
      HTML_ID: localizedSectioning.algorithmicErrorsPreventing.$children["for-direction"].$anchor
    }).Article-Heading3

    +CodeViewer--YDF({ title: "Rule Configuration" })
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.JSON }).
        { "for-direction": "error" }

    +Blockquote--YDF

      p.Article-Paragraph.
        A #[+ImportantEntity--YDID for] loop with a stop condition that can never be reached, such as one with a
          counter that moves in the wrong direction, will run infinitely.
        While there are occasions when an infinite loop is intended, the convention is to construct such loops as
          #[+ImportantEntity__Code--YDID while] loops.
        More typically, an infinite #[+ImportantEntity__Code--YDID for] loop is a bug.

      +InformationSourceReference--YDF.Blockquote--YDF-ReferenceToSource
        +Link--YDF({
          unendorsedExternalURI: "https://eslint.org/docs/latest/rules/for-direction"
        }).Article-Link Official ESLint documentation


    //- ─── no-async-promise-executor ──────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.algorithmicErrorsPreventing.$children["no-async-promise-executor"].$heading,
      HTML_ID: localizedSectioning.algorithmicErrorsPreventing.$children["no-async-promise-executor"].$anchor
    }).Article-Heading3

    +CodeViewer--YDF({ title: "Rule Configuration" })
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.JSON }).
        { "no-async-promise-executor": "error" }

    +Blockquote--YDF

      p.Article-Paragraph.
        The #[+Term--YDID executor function] can also be an #[+Term--YDID async function].
        However, this is #[+Keyword--YDID usually] a #[+Keyword__Contrast--YDID mistake], for a few reasons:

      ul.Article-UnorderedList

        li.
          If an #[+Keyword--YDID async] #[+Term--YDID executor function] throws an #[+Term__Contrast--YDID error], the
            #[+Term--YDID error] will be #[+Keyword--YDID lost] and #[+Keyword__Contrast--YDID won’t] cause the
            newly-constructed #[+ImportantEntity__Code--YDID Promise] to reject.
          This could make it difficult to debug and handle some #[+Term--YDID errors].

        li.
          If a #[+ImportantEntity__Code--YDID Promise] #[+Term--YDID executor function] is using
            #[+ImportantEntity__Code--YDID await], this is #[+Keyword--YDID usually] a sign that it
            is&nbsp;#[+Keyword--YDID not]&nbsp;actually necessary to use the #[+ImportantEntity__Code--YDID new Promise]
            #[+Term--YDID constructor], or the scope of the #[+ImportantEntity__Code--YDID new Promise]
            #[+Term--YDID constructor] can be reduced.

      +InformationSourceReference--YDF.Blockquote--YDF-ReferenceToSource
        +Link--YDF({
          unendorsedExternalURI: "https://eslint.org/docs/latest/rules/no-async-promise-executor"
        }).Article-Link Official ESLint documentation


    //- ━━━ Other Rules ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    +Heading--YDF({
      level: 2,
      text: localizedSectioning.other.$heading,
      HTML_ID: localizedSectioning.other.$anchor
    }).Article-Heading2

    //- ─── no-await-in-loop ───────────────────────────────────────────────────────────────────────────────────────────
    +Heading--YDF({
      level: 3,
      text: localizedSectioning.other.$children["no-await-in-loop"].$heading,
      HTML_ID: localizedSectioning.other.$children["no-await-in-loop"].$anchor
    }).Article-Heading3

    +CodeViewer--YDF({ title: "Rule Configuration" })
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.JSON }).
        { "no-await-in-loop": "error" }

    +Blockquote--YDF

      p.Article-Paragraph.
        Performing an operation on each element of an iterable is a common task.
        However, performing an #[+ImportantEntity__Code--YDID await] as part of #[+Keyword--YDID each] operation is an
          indication that the program is not taking full advantage of the parallelization benefits of
          #[+ImportantEntity__Code--YDID async]/#[+ImportantEntity__Code--YDID await].

      p.Article-Paragraph.
        Usually, the code should be refactored to create all the #[+Term--YDID promises] at #[+Keyword--YDID once],
          then get access to the results using #[+ImportantEntity__Code--YDID Promise.all()].
        Otherwise, each successive operation will not&nbsp;start until the previous one has completed.

      +InformationSourceReference--YDF.Blockquote--YDF-ReferenceToSource
        +Link--YDF({
          unendorsedExternalURI: "https://eslint.org/docs/latest/rules/no-await-in-loop"
        }).Article-Link Official ESLint documentation

    p.Article-Paragraph.
      This rule actual #[+Keyphrase--YDID if and only if] the procedures being executed in #[+Term--YDID promises]
        are #[+Keyphrase--YDID independent on each other].
      However, is is #[+Keyword--YDID not]&nbsp;always such as.
      For example, when call the #[+Term--YDID middleware functions] handling the #[+Term--YDID HTTP request] which are
        commonly executing asynchronous operations, #[+Keyword--YDID each] #[+Term--YDID middleware]
        #[+Keyword--YDID must] be called #[+Keyword--YDID only] when the #[+Keyword--YDID previous] one will
        done and transfer the control flow.

    p.Article-Paragraph.
      Besides, sometimes the simultaneous executing of the large number of #[+Term--YDID promises] could cause the
        problems.
      For example, if each #[+Term--YDID promise] submitting the #[+Term--YDID HTTP request], the server to which
        these requests has been submitted could consider such mass submitting from same #[+Term--YDID IP address] as
        #[+Term--YDID DoS attack] and deny the subsequent requests.
      To avoid this, it is required to submit less requests at once, or submit the requests with smaller frequency,
        or both.

    p.Article-Paragraph
      | However, because the usage of the #[+Term--YDID parallelism] is #[+Keyword--YDID commonly] recommended,
      |   violating this rule, the comment with clear explanation why this rule has been violated
      |   #[+Keyword--YDID must] be left.
      | For example, in
      |
      +Link--YDF({
        unendorsedExternalURI: sharedExternalLinks.yamatoDaiwaBackend.npm
      }).Article-Link Yamato Daiwa Backend
      |
      | framework, when sequentially invoke the #[+Term--YDID middleware functions], the following comment has been left:

    +CodeViewer--YDF({ title: "The Example of Reasonable Violation of \"no-await-in-loop\" Rule" })
      +CodeViewer-Listing--YDF({ codeLanguage: CodeViewer__YDF.SupportedCodesLanguages.TypeScript }).

        for (const middleware of this.middlewares) {

          let middlewareCompletionSignal: Middleware.CompletionSignal;

          try {

            /* eslint-disable-next-line no-await-in-loop --
             * The middleware handlers must be executed sequentially. */
            middlewareCompletionSignal = await middleware(normalizedRequest, response, this.configuration);

          } catch (error: unknown) {

            Logger.logError({
              errorType: "MiddlewareExecutionError",
              ...Server.localization.errors.middlewareExecutionFailed,
              occurrenceLocation: "Server.requestMasterHandler(compoundParameter)",
              caughtError: error
            });

            return response.submitWithError({ statusCode: ServerErrorsHTTP_StatusCodes.internalServerError });

          }


          if (middlewareCompletionSignal === Middleware.CompletionSignal.finishRequestHandling) {
            return;
          }

        }
