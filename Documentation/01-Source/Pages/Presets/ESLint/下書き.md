# Yamato Daiwa Style Guides

## Общие для JavaScript и TypeScript правила
### Валидность ECMA-кода
### Предотвращение алгоритмических ошибок
### Не должно быть в продакшен-сборке
### Предотвращение запутывания и непонимания, чего делает

#### `@stylistic/no-confusing-arrow`

```json
{
  "no-confusing-arrow": [ "error", { "allowParens": true } ]
}
```

> Arrow functions (`=>`) are similar in syntax to some comparison operators (`>`, `<`, `<=`, and `>=`). 
> This rule warns against using the arrow function syntax in places where it could be confused with a comparison operator.
>
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/no-confusing-arrow)

Тут важно добавить опцию `allowParens: true` - это одно из действий, которое нужно выполнить для устранения конфликта 
  этого правила с `no-extra-parens` в выражениях типа 
`preValidationModifications: (rawValue: unknown): unknown => (isNumber(rawValue) ? rawValue.toString() : rawValue), }` 
(последнему нужно также добавить `enforceForArrowConditionals: false`).


#### `@stylistic/no-mixed-operators`

```json
{ 
  "@stylistic/no-mixed-operators": "error"
}
```

> Enclosing complex expressions by parentheses clarifies the developer's intention, which makes the code more readable. 
> This rule warns when different operators are used consecutively without parentheses in an expression.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/no-mixed-operators)

Смешанные операторы действительно сильно запутывают.



### Предотвращение использования нерекомендуемой функциональности
### Устранение бесполезного кода

#### `@stylistic/no-extra-parens`

```json
{
  "@stylistic/no-extra-parens": [
    "warn",
    "all",
    {
      "nestedBinaryExpressions": false,
      "enforceForArrowConditionals": false
    }
  ]
}
```

> This rule restricts the use of parentheses to only where they are necessary.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/no-extra-parens)

Задачей этого правила является предотвращение случаев, когда программист думает, что скобки нужны, а на самом деле 
  не нужны, то есть не влияют на порядок действий. 
Тем не менее скобки применяются не только для изменения порядка действий, но и для улучшения читабельности кода. 
По нашему опыту, есть нужда в исключениях `nestedBinaryExpressions` (когда идёт сложная комбинация "и" и "или", добавить 
  пример) и `enforceForArrowConditionals` - для устранения конфликта с `no-confusing-arrow`.


#### `@stylistic/no-extra-semi`

```json
{
  "@stylistic/no-extra-semi": "error"
}
```

> Typing mistakes and misunderstandings about where semicolons are required can lead to semicolons that are unnecessary. 
> While not technically an error, extra semicolons can cause confusion when reading code.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/no-extra-semi)

Данное правило нацелено не на использование точки с запятой как таковой, а на использование её тогда, когда она
  обычно не требуется (например, две подряд идущие точки с запятой или точка с запятой после метода).


### Опрятность
#### `@stylistic/lines-around-comment`

```json
{
  "@stylistic/lines-around-comment": [
    "warn",
    { "beforeBlockComment": true }
  ]  
}

```

> Many style guides require empty lines before or after comments. 
> The primary goal of these rules is to make the 
>   comments easier to read and improve readability of the code.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/lines-around-comment)
 
Если перед комментарием не ставить пробел, будет мешанина.


#### `@stylistic/lines-between-class-members`

```json
{
  "@stylistic/lines-between-class-members": [
    "warn",
    {
      "enforce": [
        {
          "blankLine": "always",
          "prev": "field",
          "next": "method"
        },
        {
          "blankLine": "always",
          "prev": "method",
          "next": "method"
        },
        {
          "blankLine": "always",
          "prev": "method",
          "next": "field"
        }
      ]
    }
  ]
}
```

> This rule improves readability by enforcing lines between class members. 
> It will not check empty lines before the first member and after the last member, since that is already taken care 
>   of by padded-blocks.
>
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/lines-between-class-members)

Если писать членов класса слитно, получится мешанина.
Мы можем опускать пустые строки разве что между полями класса, когда они однородные. 


#### `@stylistic/max-len`

```json
{
  "@stylistic/max-len": [
    "warn",
    {
      "code": 130,
      "ignoreUrls": true,
      "ignorePattern": "^\\s{4}\"[@~]?[\\w/:.-]+\";\\s*$"
    }
  ]
}
```

> Very long lines of code in any language can be difficult to read. 
> In order to aid in readability and maintainability many coders have developed a convention to limit lines of code to
> X number of characters (traditionally 80 characters).
>
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/max-len)

Мы считаем, что 80 колонок - маловато, даже при отступе в 2 проблема.
Мы обычно берём 120 колонок за норму и стараемся её не нарушать, но максимально допустимую длину устанавливаем в 130. 

Тут важно добавить исключение для деклараций импортов так как разорвать пути нельзя. 
Также, если не установить исключение для ссылок в комментариях, то по этим ссылкам просто нельзя будет перейти.

#### `@stylistic/max-statements-per-line`

```json
{
  "@stylistic/max-statements-per-line": [ "warn", { "max": 2 } ]
}
```

> A line of code containing too many statements can be difficult to read. 
> Code is generally read from the top down, especially when scanning, so limiting the number of statements allowed on 
>   a single line can be very beneficial for readability and maintainability.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/max-statements-per-line)

Двух вполне достаточно, например когда создаём простую функцию типа `function foo() { bar = 1; }`.


#### `@stylistic/member-delimiter-style`

```json
{
  "@typescript-eslint/member-delimiter-style": [
    "warn",
    {
      "multiline": {
        "delimiter": "semi",
        "requireLast": true
      },
      "singleline": {
        "delimiter": "semi",
        "requireLast": true
      }
    }{}
  ]
}
```

> TypeScript allows three delimiters between members in interfaces and type aliases.
> 
> (...)
> 
> This rule enforces keeping to one configurable code style. 
> It can also standardize the presence (or absence) of a delimiter in the last member of a construct, as well as 
>   a separate delimiter syntax for single line declarations.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/member-delimiter-style)

Велик соблазн вообще отказаться от разграничителей, но это не будет вписываться в общую стилистику кода, где хотя и 
  по высосанным из пальца, на причинам разграничители используются. 
Точка с запятой выбрана потому, чтобы объявление типа контрастировало с инициализацией переменных (например, когда 
  параметр типа "объект" сразу же разбирается.)


#### `@stylistic/no-mixed-spaces-and-tabs`

```json
{
  "@stylistic/no-mixed-spaces-and-tabs": "warn"
}
```

> Most code conventions require either tabs or spaces be used for indentation. 
> As such, it's usually an error if a single line of code is indented with both tabs and spaces.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/no-mixed-spaces-and-tabs)

В принципе нарушение этого правила не критично (для ECMAScript, но не для indent-based языков), 
  но нам как-то лучше когда всё под контролем.


#### `@stylistic/no-multi-spaces`

```json
{
  "@stylistic/no-multi-spaces": "warn"
}
```

Одного пробела вполне достаточно для нормальной читабельности.


#### `@stylistic/no-multiple-empty-lines`

```json
{
  "@stylistic/no-multiple-empty-lines": [
    "warn",
    {
      "max": 2,
      "maxBOF": 0,
      "maxEOF": 1
    }
  ]
}
```

> Some developers prefer to have multiple blank lines removed, while others feel that it helps improve readability. 
> Whitespace is useful for separating logical sections of code, but excess whitespace takes up more of the screen.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/no-multiple-empty-lines)

Мы не согласны с тем, что в документации сказано про "while others feel that it helps improve readability", напротив,
  когда весь код сжат в одну кучу, его намного тяжелее читать.
Это подобно тому, как кто-нибудь при выступлении долго и монотонно говорит без пауз - согласитесь, слушать такое тяжело.
Качественный код необходимо разбивать на логические блоки, и пустые строки - один из способов это сделать.

Что касается "excess whitespace takes up more of the screen", то файл с кодом - это не страница книги, и здесь
  пространство не так важно, как читаемость.
Ну и конечно, беспокоиться о том, что код с пустыми строками займёт больше памяти не стоит, так как современные инструменты
  разработки могут минифицировать код.

Мы разрешаем максимум 2 пустых строки - случаев, для которых по какой-то более-менее высосанной из пальца причине нужно 
  больше, не возникало. 
В начале файла ставить пустые строки причины нет. 
Пустая строка в конце файла требуется другим правилом - кажется eof.

#### `@stylistic/object-curly-newline`

```json
{
  "@stylistic/object-curly-newline": [ "warn", { "consistent": true } ]
}
```

> A number of style guides require or disallow line breaks inside of object braces and other tokens.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/object-curly-newline)

Всегда бывает по-разному.  
Иногда и три коротких свойства можно в одной строке уписать, иногда и одно свойство довольно длинное, 
  потому его нужны вынести в отдельную строку. 
Тут главное быть последовательным, потому `{ "consistent": true }`.


### Унификация эквивалентных записей

#### `@stylistic/array-bracket-newline`

> Enforce linebreaks after opening and before closing array brackets.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/array-bracket-newline)

```json
{
  "@stylistic/array-bracket-newline": [ "warn", "consistent" ]
}
```

Когда один-два элемента с малым количеством символов, то не вижу смысла записывать массив в три строки: при наличии
  пробелов между элементами и скобками (правила `array-bracket-spacing` и `array-element-newline` соответственно)
  у кода достаточная читабельность:

```typescript
const sampleArray1: Array<number> = [ 1 ];
const sampleArray2: Array<number> = [ 1, 2 ];
```

Когда же элементов много, то запись в одну строку может привести к нарушению правила `@stylistic/max-len`, поэтому в 
  таких случаях следует записывать в несколько строк.


#### `@stylistic/array-bracket-spacing`

> A number of style guides require or disallow spaces between array brackets and other tokens. 
> This rule applies to both array literals and destructuring assignments (ECMAScript 6).
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/array-bracket-spacing)

```json
{
  "@stylistic/array-bracket-newline": [ "warn", "consistent" ]
}
```

Считаю, что в исходном коде читабельность гораздо важнее компактности.
Наличие подобных пробелов сходно чёткой речи с правильно расставленными паузами - такую речь довольно приятно слушать.


#### `@stylistic/array-element-newline`

```json
{
  "@stylistic/array-element-newline": [ "warn", "consistent" ]  
}
```

> A number of style guides require or disallow line breaks between array elements.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/array-element-newline)

Я не согласен с предпочтениями разработчиков ESLint насчёт того, что даже если в длинных массивах первый элемент 
  записан на одной строке со скобкой, то следующий нужно писать на новой строке:

```javascript
const c = [1,
    2];

const d = [1,
    2,
    3];

const d = [
  1,
  2,
  3
];
```

Допускаю обе формы записи - в одну строку для коротких массивов и в несколько для длинных.


#### `@stylistic/arrow-parens`

```json
{
  "@stylistic/arrow-parens": [ "warn", "always" ]  
}
```

> Arrow functions can omit parentheses when they have exactly one parameter. 
> In all other cases the parameter(s) must be wrapped in parentheses. 
> This rule enforces the consistent use of parentheses in arrow functions.
>
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/arrow-parens)

У нас основным языком является TypeScript, а в TypeScript аннотировать тип параметра без скобок невозможно, 
  даже если параметр один. 
Поэтому скобки обязательны.


#### `@stylistic/arrow-spacing`

```json
{
  "@stylistic/arrow-spacing": [ "warn", { "before": true, "after": true } ]
}
```

> This rule normalize style of spacing before/after an arrow function's arrow(`=>`)
>
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/arrow-spacing)

В целом, мы расставляем пробелы для удобочитаемости, и тут тоже так.


#### `@stylistic/block-spacing`

```json
{
  "@stylistic/block-spacing": [ "warn", "always" ] 
}
```

> This rule enforces consistent spacing inside an open block token and the next token on the same line. 
> This rule also enforces consistent spacing inside a close block token and previous token on the same line.
>
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/block-spacing)

В целом, мы расставляем пробелы для удобочитаемости, и тут тоже так.


#### `@stylistic/brace-style`

```json
{
  "@stylistic/brace-style": [ "warn", "1tbs", { "allowSingleLine": true } ]
}
```

> Brace style is closely related to [indent style](https://en.wikipedia.org/wiki/Indent_style) in programming and 
>   describes the placement of braces relative to their control statement and body. 
> There are probably a dozen, if not more, brace styles in the world.
> This rule also enforces consistent spacing inside a close block token and previous token on the same line.
>
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/brace-style)

Для ECMAScript типичен стиль 1tbs, и мы его тоже придерживаемся. 
Лишь изредка возникает соблазн написать в стиле Олмана (пример).


#### `@stylistic/comma-dangle`

```json
{
  "@stylistic/comma-dangle": [ "warn", "never" ]
}
```

> This rule enforces consistent use of trailing commas in object and array literals.
>
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/comma-dangle)

Мы не ставим запятые, потому что они создают ощущение недописанного кода. 
Действительно, в СКВ смотрится чище при добавлении строк, но это незначительно.


#### `@stylistic/comma-spacing`

```json
{
  "@stylistic/comma-spacing": [ "warn", { "before": false, "after": true } ]
}
```

> Spacing around commas improves readability of a list of items. 
> Although most of the style guidelines for languages prescribe adding a space after a comma and not before it, 
>   it is subjective to the preferences of a project.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/comma-spacing)

В соответствии с правилами обычной грамматики, к которой должен быть максимально близок легко читаемый код, 
  пробел нужно ставить после запятой, а не перед.


#### `@stylistic/comma-style`

```json
{
  "@stylistic/comma-style": [　"error",　"last"　]
}
```

> The Comma Style rule enforces styles for comma-separated lists.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/comma-style)

Мы придерживаемся стандартной записи, при которой сначала ставится запятая, а потом идёт перенос строки потому что 
  особых причин для другого стиля нет. 
"One of the justifications for using Comma First style is that it can help track missing and trailing commas." - 
  для TypeScript вкупе с запретом на trailing commas это не имеет значения.


#### `@stylistic/computed-property-spacing`

```json
{
  "@stylistic/computed-property-spacing": [　"warn",　"never"　]
}
```

> While formatting preferences are very personal, a number of style guides require or disallow spaces between computed
>   properties in the following situations:
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/computed-property-spacing)

Мы в данном случае пробел не ставим, чтобы был контраст с массивами, где пробелы уже обязательны в наших правилах.


#### `stylistic/dot-location`

```json
{
  "@stylistic/dot-location": [ "warn", "object" ]  
}
```

> JavaScript allows you to place newlines before or after a dot in a member expression.
> Consistency in placing a newline before or after the dot can greatly increase readability.
>
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/dot-location)


Здесь мы придерживаемся нестандартного стиля - object. 
Такой стиль написания был унифицирован с правилом написания знаков арифметических действий, где согласно принципу 
  предсказуемости кода знак остаётся на строке перед переносом. 
В данном случае мы также понимаем, что если n-ая строка заканчивается на точку, значит в n+1-ой строке будет что-то вызвано.


#### `@stylistic/function-call-argument-newline`

```json
{
  "@stylistic/function-call-argument-newline": [ "warn", "consistent" ]
}
```

> A number of style guides require or disallow line breaks between arguments of a function call.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/function-call-argument-newline)

Мы позволяем оба способа, потому что когда аргументы короткие, запись их в одну строчку вполне себе читаема 
  (запятая и пробел чётко разделяют их), но иногда имена аргументов могут быть длинными и тогда их в одну строку 
  просто не уместить. 
Главное - не писать вразнобой и соответствующая опция, к счастью, имеется.


#### `@stylistic/function-call-spacing`

```json
{
  "@stylistic/function-call-spacing": "warn"
}
```

> When calling a function, developers may insert optional whitespace between the function's name and the parentheses that 
>   invoke it. 
> The following pairs of function calls are equivalent.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/function-call-spacing)

Споры о том, что легче читать тут могут быть бесконечны. 
В принципе запись типа имя функции() без пробела пере скобками - стандартное для многих языков выражение вызова 
  функции/метода.


#### `@stylistic/function-paren-newline`

```json
{
  "@stylistic/function-paren-newline": [ "warn", "consistent" ]
}
```

> Many style guides require or disallow newlines inside of function parentheses.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/function-paren-newline)

Мы позволяем оба способа, потому что когда аргументы короткие, запись их в одну строчку вполне себе читаема 
  (запятая и пробел чётко разделяют их), но иногда имена аргументов могут быть длинными и тогда их в одну строку 
  просто не уместить. 
Главное - не писать вразнобой и соответствующая опция, к счастью, имеется.


#### `@stylistic/generator-star-spacing`

```json
{
  "@stylistic/generator-star-spacing": [ "warn", { "before": true, "after": false } ] 
}
```

> Generators are a new type of function in ECMAScript 6 that can return multiple values over time. 
> These special functions are indicated by placing an `*` after the `function` keyword.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/generator-star-spacing)


#### `@stylistic/key-spacing`

```json
{
  "@stylistic/key-spacing": [
    "warn",
    {
      "beforeColon": false,
      "afterColon": true,
      "mode": "strict"
    }
  ]
}
```

> This rule enforces spacing around the colon in object literal properties. 
> It can verify each property individually, or it can ensure horizontal alignment of adjacent properties in an object literal.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/key-spacing)

У нас никаких логических возражений против наиболее устоявшейся формы записи, при которой перед двоеточием пробела нет, 
  а после него - есть.


#### `@stylistic/keyword-spacing`

```json
{
  "@stylistic/keyword-spacing": [
    "warn",
    {
      "before": true,
      "after": true
    }
  ]
}
```

Мы размежаем ключевые словам пробелами дабы они не сливались с остальными токенами.


#### `@stylistic/new-parens`

```json
{
  "@stylistic/new-parens": "error"
}
```

> JavaScript allows the omission of parentheses when invoking a function via the new keyword and the constructor has 
>   no arguments. 
> However, some coders believe that omitting the parentheses is inconsistent with the rest of the language and thus 
>   makes code less clear.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/new-parens)

Мы считаем, что вызов функции-конструктора, как и вызов других функций должен иметь скобки, как и во многих других
  C-подобных языках.
Вариант без скобок объявляется невалидным синтаксисом.


#### `@stylistic/newline-per-chained-call`

```json
{
  "@stylistic/newline-per-chained-call": [ "warn", { "ignoreChainWithDepth": 2 } ]
}
```

> Chained method calls on a single line without line breaks are harder to read, so some developers place a newline 
>   character after each method call in the chain to make it more readable and easy to maintain.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/newline-per-chained-call)


Мы допускаем запись в одну строчку цепи из двух вызовов, но при трёх и более вызовах требуем переноса строки,
   так как это становится тяжелее читать.


#### `@stylistic/no-floating-decimal`

```json
{
  "@stylistic/no-floating-decimal": "error"
}
```

> Although not a syntax error, this format for numbers can make it difficult to distinguish between true decimal 
>   numbers and the dot operator. 
> For this reason, some recommend that you should always include a number before and after a decimal point to make it
>   clear the intent is to create a decimal number.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/no-floating-decimal)

Мы всегда (в том числе в и в CSS) требуем указывать 0 перед точкой, потому что это верно математически.
Чтобы сделать синтаксис без скобок невалидным, данное нарушения данного правила имеют статус error.


#### `"@stylistic/no-whitespace-before-property`

```json
{
  "@stylistic/no-mixed-spaces-and-tabs": "warn"
}
```

> JavaScript allows whitespace between objects and their properties. 
> However, inconsistent spacing can make code harder to read and can lead to errors.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/no-whitespace-before-property)

Спорить о том, что легче читать, можно бесконечно, поэтому тут мы придерживаемся популярной формы записи - без пробела.


#### "@stylistic/object-curly-spacing" 

```json
{
  "@stylistic/object-curly-spacing": [ "warn", "always" ]
}
```

> While formatting preferences are very personal, a number of style guides require or disallow spaces between curly 
> braces in the following situations:
> 
> ```javascript
> // simple object literals
> var obj = { foo: "bar" };
> 
> // nested object literals
> var obj = { foo: { zoo: "bar" } };
>
> // destructuring assignment (EcmaScript 6)
> var { x, y } = y;
>
> // import/export declarations (EcmaScript 6)
> import { foo } from "bar";
> export { foo };
> ```
>
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/object-curly-spacing)

Мы всегда ставим пробелы. 
Сказать субъективно, что "так выглядит грязнее" или "так сложнее читать" можно, но это будет спорно.


#### @stylistic/object-property-newline

```json
{
  "@stylistic/object-property-newline": [
    "warn",
    {
      "allowAllPropertiesOnSameLine": true
    }
  ]
}
```

> This rule permits you to restrict the locations of property specifications in object literals. 
> You may prohibit any part of any property specification from appearing on the same line as any part of any other 
> property specification. 
> You may make this prohibition absolute, or, by invoking an object option, you may allow an exception, permitting
> an object literal to have all parts of all of its property specifications on a single line.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/object-property-newline)

Достаточно исключения allowAllPropertiesOnSameLine.


#### `@stylistic/operator-linebreak`

```json
{
  "@stylistic/operator-linebreak": [ "warn", "after" ]
}
```

Мы переносим строку после знака в рамках доктрины "предсказуемости кода".


#### `@stylistic/one-var-declaration-per-line`

```json
{
  "@stylistic/one-var-declaration-per-line": [ "error", "initializations" ]
}
```

Примечательно, но при качественном коде соблазн записи двух и более неинициализированных переменных в одну строчку 
  возникает довольно редко, особенно для TypeScript, где помимо имени требуется указать тип 
  (мы считаем, что если этого не делать, то нельзя себя называть TypeScript-программистом). 
Имена качественных переменных зачастую не такие короткие. 
Всё это приводит к выводу, что во имя унификации можно не позволять две и более переменных на одну строку.


#### `@stylistic/quote-props`

```JSON
{ "@stylistic/quote-props": [ "warn", "as-needed" ] }
```

Данное правило можно отнести к группе "унификация... " при условии, что код у нас ES5 и старше. 
К счастью, большинство современных сред поддерживают ES6 и старше, а потому без необходимости скобок можно не ставить - 
тем более и использованием транспортеров.


#### `"@stylistic/quotes"`

```JSON
{
  "@stylistic/quotes": [ "error", "double", { "avoidEscape": true } ]
}
```

О том, какие кавычки нужно использовать, пожалуй одни из самых горячих, но в то же время бесполезных споров. 
Говорят, например, что одинарные кавычки - правила хорошего тона, но какого-либо логического обоснования мы не видели. 
Двойные кавычки мы выбираем как единый способ записи строчных литералов для C-подобных языков 
(в некоторых языках, например Java и C# одинарные кавычки не могут быть использованы для строчных литералов, 
а в других - как и ECMAScript доступны вариации.) 
Разумеется, мы позволяем использовать template literal, когда он нужен.


#### `"@stylistic/rest-spread-spacing"`

```JSON
{
  "@stylistic/rest-spread-spacing": [ "warn", "never" ]
}
```

Как и другие унарные операторы, мы требуем написания вплотную.


#### `"@stylistic/semi"`

```json
{
  "@stylistic/semi": "error" 
}
```

Ещё одна тема для бесполезных холиваров наряду с двойными и одинарными кавычками. 
Скажем так: JavaScript да и многие другие C-подобные языки не разрабатывались как языки с лаконичными ситаксисом 
  (как Питон), а потому обойтись без точек с запятой во 100% невозможно (например, в for). 
Поэтому наличие точек с запятой является особенностью C-подобных языков, а JavaScript на позицию языка, 
  "значительно отдалившегося от своего предка и предвнесший гораздо более лаконичный синтаксис" не претендует.


#### `"@stylistic/semi-spacing"`

```JSON
{
  "@stylistic/semi-spacing": [ "warn", { "before": false, "after": true } ]
}
```

Мало кто скажет, что когда что-то идёт без пробела после точек с запятой, то это легче читать, чем когда есть пробел.



#### `"@stylistic/semi-style"`

```JSON
{
  "@stylistic/semi-style": [ "warn", "last" ]
}
```

Переносить точку с запятой на следующую строку можно только из непонимания концепции этого оператора. 
Этот оператор как раз является указанием того, что объявление инструкции завершено и на следующей строке будет новая 
  инструкция.


#### `"@stylistic/space-before-blocks"`

```JSON
{
  "@stylistic/space-before-blocks": "warn"
}
```

Мы размежаем согласно фундаментальному "пробелы улучшают читабельность".


#### `"@stylistic/space-before-function-paren"` 

```JSON
{
  "@stylistic/space-before-function-paren": [ "warn", { "anonymous": "always", "named": "never", "asyncArrow": "always" } ]
}
```

Скобки, идущие сразу после идентификатора указывают, что это вызов функции/метода. 
Это типично для C-подобных языков. 
Пробел после скобок уже даёт хорошую читабельность. 
Но поскольку анонимные функции (в частности, асинхронные) имени не содержат, то для них - исключение.


#### `"@stylistic/space-in-parens"`

```JSON
{
  "@stylistic/space-in-parens": [ "warn", "never" ]
}
```

Тут наличие пробелов в принципе мало что даёт. 
Можно сказать, что `const x = ( 1 + 2 ) * 3;` читается легче, `чем const x = (1 + 2) * 3;`, 
но данное распространяется и на `foo( 'bar' );`, а добавить исключение для одного члена нельзя.


### Другие

#### `@stylistic/eol-last`

```json
{
  "@stylistic/eol-last": [　"error",　"warn"　]
}
```

> Trailing newlines in non-empty files are a common UNIX idiom. 
> Benefits of trailing newlines include the ability to concatenate or append to files as well as output files to the 
>   terminal without interfering with shell prompts.
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/eol-last)

Мы приняли это правило, потому что несмотря на его мерзость аргументов, доказывающих безопасность игнорирования этой 
  идиомы у нас не нашлось.
Мерзость заключается в том, что для третьего десятилетия 21-го века с его искусственными интеллектами машинам пора бы 
  уже самостоятельно обрабатывать случай, когда последняя пустая строка отсутствует.

### Не вошли

#### `consistent-return`

Данное правило является конфликтным, например конфликтует с `no-useless-return` или `no-undefined`.
TypeScript сам разругается, если возвращаемое значение не соответствует аннотированному, так что от данного правила можно
  отказаться при условии, что аннотация возвращаемого типа обязательна..


#### `prefer-template`

> Require template literals instead of string concatenation
>
> [ESLint official documentation](https://eslint.org/docs/latest/rules/prefer-template)

Какое-то время мы использовали это правила, однако в какой-то момент оно 
  [стало конфликтовать с "@typescript-eslint/no-useless-template-literals"](https://stackoverflow.com/q/78046218/4818123).
Вновь проанализировав [документацию для "prefer-template"](https://eslint.org/docs/latest/rules/prefer-template) мы
  заметили, что все примере являются однострочными (проверено в марте 2024 года), например `"Hello, " + name + "!";`,
  а в случах нескольких строк [возникают проблемы](https://stackoverflow.com/q/78046218/4818123).
В итоге, принято решение отказаться от этого правила из-за этих проблем.


#### `@stylistic/implicit-arrow-linebreak`

Для коротких функций мы допускаем запись в одну строку, а в случае длинных функций разбиваем на несколько строк, причём
  перенос делаем после стрелки по принципу предсказуемости.


#### `@stylistic/linebreak-style`

> When developing with a lot of people all having different editors, VCS applications and operating systems it may occur
>   that different line endings are written by either of the mentioned (might especially happen when using the 
>   windows and mac versions of SourceTree together).
> 
> [ESLint Stylistics official documentation](https://eslint.style/rules/default/linebreak-style)

Сделать это правило по умолчанию (в зависимости от ОС) вполне безопасно, потому что системы контроля версий, 
  без которых не обходится ни один современный серьёзный проект, могут автоматически заменять 
  escape-последовательности на нужные.


#### `@stylistic/multiline-ternary`

Всё зависит от длины операндов. 
Опция always-multiline не покрывает те случаи, когда один операнд короткий, а другой - длинный. 


#### `@stylistic/no-tabs`

На данный момент не видим особой причины запрещать табы.


#### `@stylistic/no-trailing-spaces`

На соблюдение этого правила может потребоваться много времени. 
Хотя мы этого не замечаем, мы чуть ли не в каждом строке оставляем один или более пробелов. 
В процессе написания кода, ESLint будет буквально спамить за нарушение этого правила. 
Поскольку нарушение этого правила никаких отрицательных эффектов типа снижения производительности 
(если брать веб-приложения, то там минификация продакшен-кода - стандартная процедура), то соблюдать его особого смысла нет.


#### `nonblock-statement-body-position`

Наличие правила `curly` делает это правило ненужным.



#### `@stylistic/padded-blocks`

В целом, правило небесполезное, но к сожалению, у него недостаточно опций, чтобы настроить его под наши гайдлайны. 
А подход наш таков: если блок состоит из одной -двух строк, то тогда добавление в него отступов особо читабельность 
  не увеличит, а вот если там какие-то более сложные алгоритмы, где последовательности можно разбивать на группы, 
  то тогда добавление отступов уже требуется.


#### `@stylistic/padding-line-between-statements`

Мы осуществляем группировку в последовательности строк без пробелов в первую очередь семантически.
Поэтому вгонять себя в жесткие рамки типа "отступов никогда не должно быть" или "они должны быть всегда" мы не будет.
Опций, конечно, много, но семантику они понять немогут.


## TypeScript
### Безопасность типизации
#### `use-unknown-in-catch-callback-variables`

```json
{
  "use-unknown-in-catch-callback-variables": "error"
}
```

> This rule enforces that you always use the unknown type for the parameter of a `Promise.prototype.catch()` callback.
>
> [TypeScript-ESLint official documentation](https://typescript-eslint.io/rules/use-unknown-in-catch-callback-variable/)

Использование `any`, в том числе в обработчиках ошибок - это смертный грех, за который инженер не имеет право
  упомянуть TypeScript среди используемых технологий в резюме.


### Предотвращение алгоритмических ошибок

#### `@typescript-eslint/no-array-delete`

```json
{
  "@typescript-eslint/no-array-delete": "error"
}
```

> When using the delete operator with an array value, the array's length property is not affected, but the element at 
>   the specified index is removed and leaves an empty slot in the array. 
> This is likely to lead to unexpected behavior. 
> As mentioned in the MDN documentation, the recommended way to remove an element from an array is by using the 
>   `Array#splice` method.
> 
> [TypeScript-ESLint official documentation](https://typescript-eslint.io/rules/no-array-delete/)
